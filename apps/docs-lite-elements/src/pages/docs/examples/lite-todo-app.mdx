import { DepsManager } from '@eco-pages/core';
import { DocsLayout } from '@/layouts/docs-layout';
import { CodeBlock } from '@/components/code-block/code-block.kita';
import { LiteTodoApp } from '@/components/lite-todo-app'

export const layout = DocsLayout;

export const dependencies = DepsManager.collect({
  importMeta: import.meta,
  components: [LiteTodoApp]
})

export const getMetadata = () => ({
  title: 'Docs | Lite Todo App',
  description: 'The place to learn about Eco Pages',
})

# Lite Todo App
---

The `LiteTodoApp` component is a simple todo app that uses the `ContextProvider` to share the data between components.

In this example we are using `WithKita` mixin to use JSX in our components.

The features of this todo app are:

- Add a todo
- Mark a todo as completed
- Show the number of todos and completed todos
- Move a todo to the completed list once it is marked as completed
- Move a todo to the todo list once it is marked as incomplete
- Show a message when there are no todos to show

Also if the list of the features seems not to be so big, there is a lot of concepts that are being used in this example.

Let's check it together.

<LiteTodoApp count={5} />

## Jsx Markup

This is the jsx markup of the `LiteTodoApp` component.

As you can see we are using the `hydrate-context` attribute to pass the initial data to the `ContextProvider` provider.

This is very handy in a SSR context, where we can pass the data from the server to the client keeping the UX consistent.

To pass the data to the `hydrate-context` attribute we need to use the `stringifyAttribute` helper to convert the data to a string but being sure that the data will be parsed correctly.

Please remember that due the nature of the web components, you need to stringify the data before passing it to the component, but context can also have properties that cannot be stringified.

Since hydrate will merge the data with the initial value, you can pass only the properties that you want to update.

<CodeBlock lang="jsx">{`<lite-todo-app class="todo" hydrate-context={stringifyAttribute<TodoContext>({ todos: data.todos })}>
  <div>
    <article>
      <h4>Todo List</h4>
      <p>
        Still to do: <span data-ref="count-incomplete">{incompleteTodos.length}</span>
      </p>
      <div data-ref="list-incomplete">
        {completedTodos.length > 0 
          ? <TodoList todos={incompleteTodos} /> 
          : <NoTodosMessage />
        }
      </div>
    </article>
    <article>
      <h4>Completed Todos</h4>
      <p>
        Completed: <span data-ref="count-complete">{completedTodos.length}</span>
      </p>
      <div data-ref="list-complete">
        {incompleteTodos.length > 0 
          ? <TodoList todos={completedTodos} /> 
          : <NoCompletedTodosMessage />
        }
      </div>
    </article>
  </div>
  <form>
    <div>
      <label for="new-todo">Add Todo</label>
      <input id="new-todo" name="todo" />
    </div>
    <button type="submit">Add</button>
  </form>
</lite-todo-app>
`}</CodeBlock>

## Typescript

In this first snippet we have the `lite-todo-app` component that is responsible for managing the todos.

The features used in this component are:

- `@ref` decorator to query for the elements inside the component that uses the `data-ref` attribute
- `@provideContext` decorator to provide the context to the children components
- `@onEvent` decorator to listen for the form submit event
- `@contextSelector` decorator to select the todos based on the complete status
- `renderTemplate` method to render the templates. Here we are using WithKita mixin to render the JSX templates

<CodeBlock lang='typescript'>{`export type Todo = {
  id: string;
  text: string;
  complete: boolean;
};

export type TodoContext = {
  todos: Todo[];
};

export const todoContext = createContext<TodoContext>(Symbol('todo-context'));

@customElement('lite-todo-app')
export class LiteTodoApp extends WithKita(LiteElement) {
  @query({ ref: 'list-complete' }) listComplete!: HTMLElement;
  @query({ ref: 'list-incomplete' }) listIncomplete!: HTMLElement;
  @query({ ref: 'count-complete' }) countComplete!: HTMLElement;
  @query({ ref: 'count-incomplete' }) countIncomplete!: HTMLElement;

  @provideContext<typeof todoContext>({
    context: todoContext,
    initialValue: { todos: [], logger: new Logger() },
    hydrate: Object,
  })
  provider!: ContextProvider<typeof todoContext>;

  @onEvent({ selector: 'form', type: 'submit' })
  submitTodo(event: FormDataEvent) {
    event.preventDefault();
    const form = event.target as HTMLFormElement;
    const formData = new FormData(form);
    const todo = formData.get('todo');

    if (todo) {
      const prevTodos = this.provider.getContext().todos;
      const todos = [...prevTodos, { id: Date.now().toString(), text: todo.toString(), complete: false }];
      this.provider.setContext({ todos });
      form.reset();
    }
  }

  @contextSelector({
    context: todoContext,
    select: ({ todos }) => ({
      todosCompleted: todos.filter((todo) => todo.complete),
      todosIncomplete: todos.filter((todo) => !todo.complete),
    }),
  })
  onTodosUpdated({ todosCompleted, todosIncomplete }: Record<string, TodoContext['todos']>) {
    const todosMapping = [
      { todos: todosCompleted, list: this.listComplete, noTodosMessage: <NoTodosMessage /> },
      { todos: todosIncomplete, list: this.listIncomplete, noTodosMessage: <NoCompletedTodosMessage /> },
    ];

    for (const { todos, list, noTodosMessage } of todosMapping) {
      if (todos.length === 0) {
        this.renderTemplate({
          target: list,
          template: noTodosMessage,
        });
      } else {
        this.renderTemplate({
          target: list,
          template: <TodoList todos={todos} />,
        });
      }
    }

    this.countComplete.textContent = todosCompleted.length.toString();
    this.countIncomplete.textContent = todosIncomplete.length.toString();
  }
}

declare global {
  namespace JSX {
    interface IntrinsicElements {
      'lite-todo-app': HtmlTag;
      'lite-todo-item': HtmlTag & LiteTodoProps;
    }
  }
}
`}</CodeBlock>

In this second snippet we have the `lite-todo-item` component that is responsible for rendering the todo item.

The features used in this component are:

- `@query` decorator to query for the checkbox element
- `@reactiveProp` decorator to define the complete attribute
- `@consumeContext` decorator to consume the context from the parent component

<CodeBlock lang='typescript'>{`export type LiteTodoProps = {
  complete?: boolean;
};

@customElement('lite-todo-item')
export class LiteTodoItem extends WithKita(LiteElement) {
  @query({ selector: 'input[type="checkbox"]' }) checkbox!: HTMLInputElement;
  @query({ selector: 'button' }) removeButton!: HTMLButtonElement;
  @reactiveProp({ type: Boolean, reflect: true }) complete = false;
  @consumeContext(todoContext) context!: ContextProvider<typeof todoContext>;

  override connectedCallback(): void {
    super.connectedCallback();
    this.complete = this.checkbox.checked;
  }

  @onEvent({ selector: 'input[type="checkbox"]', type: 'change' })
  toggleComplete(event: Event) {
    const checkbox = event.target as HTMLInputElement;
    const todo = this.context.getContext().todos.find((t) => t.id === this.id);
    if (!todo) return;

    this.complete = checkbox.checked;

    this.context.setContext({
      todos: this.context.getContext().todos.map((t) => (t.id === this.id ? { ...t, complete: checkbox.checked } : t)),
    });

    const logger = this.context.getContext().logger;
  }

  @onEvent({ ref: 'remove-todo', type: 'click' })
  removeTodo() {
    this.context.setContext({
      todos: this.context.getContext().todos.filter((t) => t.id !== this.id),
    });

    const logger = this.context.getContext().logger;
  }
}

declare global {
  namespace JSX {
    interface IntrinsicElements {
      'lite-todo-item': HtmlTag & LiteTodoProps;
    }
  }
}`}</CodeBlock>

Finally, in this last snippet we have the `NoTodosMessage`, `NoCompletedTodosMessage`, `TodoItem` and `TodoList` components.

Theses components are responsible for rendering the messages when there are no todos to show, the todo item and the todo list.

They are used both in the initial markup and in the custom elements.

<CodeBlock lang='typescript'>{`import type { Todo } from './lite-todo-app.script';

export const NoTodosMessage = () => {
  return <div>No todos to show</div>;
};

export const NoCompletedTodosMessage = () => {
  return <div>No completed todos to show</div>;
};

export const TodoItem = ({ id, complete, text }: Todo) => {
  return (
    <lite-todo-item complete={complete} class="todo__item" id={id}>
      {text as 'safe'}
      <span>
        <input type="checkbox" checked={complete} />
      </span>
       <button type="button" class="todo__item-remove">
        <svg
          width="20"
          height="20"
          aria-hidden="true"
          focusable="false"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
          class="lucide lucide-x"
        >
          <path d="M18 6 6 18" />
          <path d="m6 6 12 12" />
        </svg>
      </button>
    </lite-todo-item>
  );
};

export const TodoList = ({ todos }: { todos: Todo[] }) => {
  return (
    <>
      {todos.map((todo) => (
        <TodoItem {...todo} />
      ))}
    </>
  );
};`}</CodeBlock>