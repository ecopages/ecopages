import { CodeBlock } from '@/components/code-block/code-block.kita';
import { DocsLayout } from '@/layouts/docs-layout';

export const layout = DocsLayout;

export const getMetadata = () => ({
	title: 'Docs | Custom Integration',
	description: 'Learn how to create custom integrations in Ecopages',
});

# Creating Custom Integrations

Integrations in Ecopages add support for new templating engines or frameworks. This guide will show you how to create your own integration.

## Basic Structure

An integration extends the `IntegrationPlugin` abstract class:

<CodeBlock>
```typescript
import { IntegrationPlugin } from '@ecopages/core/plugins/integration-plugin';
import type { IntegrationRenderer } from '@ecopages/core/route-renderer/integration-renderer';

class CustomIntegration extends IntegrationPlugin {
constructor() {
super({
name: 'custom-integration',
extensions: ['.custom'], // File extensions to handle
});
}

createRenderer(): IntegrationRenderer {
return new CustomRenderer({
appConfig: this.appConfig!,
});
}
}

````
</CodeBlock>

## Creating a Custom Renderer

The renderer handles the actual transformation of your templates:

<CodeBlock>
```typescript
class CustomRenderer extends IntegrationRenderer {
  name = 'custom-renderer';

  async render(options: IntegrationRendererRenderOptions): Promise<RouteRendererBody> {
    const { Page, props, metadata, HtmlTemplate } = options;

    // Transform the page content
    const pageContent = await this.renderPage(Page, props);

    // Render the final HTML using the template
    return HtmlTemplate({
      children: pageContent,
      metadata,
    });
  }

  private async renderPage(Page: EcoComponent, props: any): Promise<string> {
    // Implement your rendering logic here
    return '';
  }
}
````

</CodeBlock>

## Handling Dependencies

Manage assets and dependencies for your integration using the `integrationDependencies` array in the constructor:

<CodeBlock>
```typescript
import { AssetFactory } from '@ecopages/core/services/asset-processing-service';

class CustomIntegration extends IntegrationPlugin {
	renderer = CustomRenderer;

	constructor() {
		super({
			name: 'custom-integration',
			extensions: ['.custom'],
			integrationDependencies: [
				AssetFactory.createFileScript({
					importPath: './runtime.js',
					position: 'head',
				}),
				AssetFactory.createFileStylesheet({
					filepath: './styles.css',
				}),
			],
		});
	}
}
```
</CodeBlock>

## Hot Module Replacement (HMR)

To support HMR in your custom integration, you need to implement an `HmrStrategy` and register it in your plugin.

### Creating an HMR Strategy

The strategy determines how file changes are handled. It should identify matches and process the updates:

<CodeBlock>
```typescript
import {
	HmrStrategy,
	HmrStrategyType,
	type HmrAction,
	type DefaultHmrContext,
} from '@ecopages/core';

class CustomHmrStrategy extends HmrStrategy {
	readonly type = HmrStrategyType.INTEGRATION;

	constructor(private context: DefaultHmrContext) {
		super();
	}

	// Determine if this strategy should handle the changed file
	matches(filePath: string): boolean {
		return filePath.endsWith('.custom');
	}

	// Process the change and return an action
	async process(filePath: string): Promise<HmrAction> {
		// Get the public URL for the changed file (if registered)
		const watchedFiles = this.context.getWatchedFiles();
		const outputUrl = watchedFiles.get(filePath) || filePath;

		// You can perform rebuilds or code transformations here
		// ...

		return {
			type: 'broadcast',
			events: [
				{
					type: 'update',
					path: outputUrl,
					timestamp: Date.now(),
				},
			],
		};
	}
}
```
</CodeBlock>

### Registering the Strategy

Override `getHmrStrategy` in your `IntegrationPlugin` to return your custom strategy:

<CodeBlock>
```typescript
class CustomIntegration extends IntegrationPlugin {
	renderer = CustomRenderer;

	override getHmrStrategy() {
		if (!this.hmrManager) return undefined;

		return new CustomHmrStrategy(this.hmrManager.getDefaultContext());
	}

	// You can also register specifier mappings for the browser
	override setHmrManager(hmrManager: IHmrManager) {
		super.setHmrManager(hmrManager);
		hmrManager.registerSpecifierMap({
			'custom-pkg': '/assets/vendors/custom-pkg-esm.js',
		});
	}
}
```
</CodeBlock>

## Setup and Teardown

Handle initialization and cleanup:

<CodeBlock>
```typescript
class CustomIntegration extends IntegrationPlugin {
  async setup(): Promise<void> {
    // Initialize resources
    // Register dependencies
    // Set up compilation
  }

async teardown(): Promise<void> {
// Clean up resources
}
}

````
</CodeBlock>

## Using the Integration

Register your integration in the Ecopages configuration:

<CodeBlock>
```typescript
import { ConfigBuilder } from '@ecopages/core';

const customIntegration = new CustomIntegration();

const config = await new ConfigBuilder()
  .setIntegrations([customIntegration])
  .build();
```
</CodeBlock>

## Best Practices

1. Follow the Single Responsibility Principle
2. Handle errors gracefully
3. Provide clear documentation
4. Use TypeScript for type safety
5. Test your integration thoroughly
6. Manage dependencies efficiently

## Example: Complete Integration

Here's a complete example of a custom integration:

<CodeBlock>
```typescript
import { IntegrationPlugin } from '@ecopages/core/plugins/integration-plugin';
import type { IntegrationRenderer } from '@ecopages/core/route-renderer/integration-renderer';
import type { 
  EcoComponent, 
  RouteRendererBody, 
  IntegrationRendererRenderOptions 
} from '@ecopages/core/public-types';

class CustomRenderer extends IntegrationRenderer {
name = 'custom-renderer';

async render(options: IntegrationRendererRenderOptions): Promise<RouteRendererBody> {
const { Page, props, metadata, HtmlTemplate } = options;

    // Transform the page
    const pageContent = await this.renderPage(Page, props);

    // Return the complete HTML
    return HtmlTemplate({
      children: pageContent,
      metadata,
      dependencies: {
        scripts: ['./runtime.js'],
        stylesheets: ['./styles.css'],
      },
    });

}

class CustomHmrStrategy extends HmrStrategy {
	readonly type = HmrStrategyType.INTEGRATION;

	constructor(private context: DefaultHmrContext) {
		super();
	}

	matches(filePath: string) {
		return filePath.endsWith('.custom');
	}

	async process(filePath: string): Promise<HmrAction> {
		const outputUrl = this.context.getWatchedFiles().get(filePath) || filePath;
		return {
			type: 'broadcast',
			events: [{ type: 'update', path: outputUrl, timestamp: Date.now() }],
		};
	}
}

export class CustomIntegration extends IntegrationPlugin {
  constructor() {
    super({
      name: 'custom-integration',
      extensions: ['.custom'],
    });
  }

	constructor() {
		super({
			name: 'custom-integration',
			extensions: ['.custom'],
		});
	}

	override getHmrStrategy() {
		return this.hmrManager
			? new CustomHmrStrategy(this.hmrManager.getDefaultContext())
			: undefined;
	}
}

async setup(): Promise<void> {
// Setup logic
}

async teardown(): Promise<void> {
// Cleanup logic
}
}

```
</CodeBlock>
